# Clean and check raw tables, then build out tables for subsequent analysis

Set knitr options:

```{r}
require(knitr)
opts_knit$set(root.dir='~/Data/Currensee/tables-2014/Rds')
```

Load data:

```{r}
library(data.table)
library(reshape2)
library(parallel)

setwd('~/Data/Currensee/tables-2014/Rds')

rm(list=ls())
options(max.print=10000)
```

Load broker accounts table, to get broker account/user mapping

```{r}
ba <- readRDS('BrokerAccount.Rds')
ba <- ba[,list(brokerAccount_id=id, user_id, baseCurrency)]
setkey(ba,brokerAccount_id)
```

Load forex position tracker table, for the meat of the problem.
Drop a bunch of (apparently) useless columns.

```{r}
# make fpt
fpt <- readRDS('ForexPositionTracker.Rds')
# fpt[,c('version','correlationId','position_id','original_id','residual_id',
#        'followedClose','brokerOrderId','stopEnterPrice','rollovers',
#        'dollarPnlExclusions','pipsPnl','closeExecutionCount',
#        'followedTrade_id','openBrokerTradePositionId','closeBrokerTradePositionId',
#        'openPersistTime','closePersistTime') := NULL]
fpt[,c('position_id',
       'followedClose','brokerOrderId','stopEnterPrice','rollovers',
       'dollarPnlExclusions','closeExecutionCount',
       'followedTrade_id','openBrokerTradePositionId','closeBrokerTradePositionId',
       'openPersistTime','closePersistTime') := NULL]
# fpt <- fpt[status=='CLOSED', !"status", with=FALSE]
gc()
```

Merge in user ids

```{r}
# add in user ids everywhere...
setkey(fpt, brokerAccount_id)
fpt <- merge(fpt, ba, all.x=TRUE)
stopifnot(all(fpt[,!is.na(user_id)]))
```

Find out how we can track followed trades

```{r}
# inspect close/open Cause_ids
# 3306275 total: 2.87 mil std follow, 432k nothing, 391 ended relationship, 134 ext close, 800 drawdown
summary(fpt[openCause_id == closeCause_id])
# 1218 total: 1067 std follow, 151 nothing
summary(fpt[openCause_id != closeCause_id])
# 4709250 total: 4.708 mil nothing, 473 ext close, 330 user init
summary(fpt[is.na(openCause_id) & is.na(closeCause_id)])
# 425 total: 425 std follow
summary(fpt[is.na(openCause_id) & !is.na(closeCause_id)])
# 103497 total: 50k nothing, 13k ended relationship, 17k drawdown, 20k ext close
summary(fpt[!is.na(openCause_id) & is.na(closeCause_id)])

# check that openCause_ids map into fpt ids
setkey(fpt,id)
fpt.follower <- fpt[!is.na(openCause_id)]
fpt.follower[, closureReason := as.factor(closureReason)]
oc.ids <- fpt.follower[, openCause_id]
fpt.followed <- fpt[J(oc.ids)]
stopifnot(length(oc.ids) == nrow(fpt.followed))
# this includes ~ 7218 open originating trades

# some summary stats
# 127 unique trade leaders, 3308 followers, 10289 total users
length(fpt.followed[, unique(user_id)])
length(fpt.follower[, unique(user_id)])
length(fpt[, unique(user_id)])
```

## Make trade leader event series
----------

Get list of all follower trades along with info about who was followed.

```{r}
followed.info <- fpt.followed[, list(openCause_id=id, tl_user_id=user_id, tl_baid=brokerAccount_id,
                                     tl_commission=commission)]
setkey(followed.info, openCause_id)
followed.info <- unique(followed.info)
setkey(fpt.follower, openCause_id)
fpt.follower <- merge(fpt.follower, followed.info, all.x=TRUE)

fpt.follower.short <- fpt.follower[, list(id, brokerAccount_id, user_id,
#                                           openTime, closeTime,
                                          openDay=floor(openTime / 86400000),
                                          closeDay=floor(closeTime / 86400000),
                                          cp=paste0(currency1,currency2),direction,status,
                                          closureReason, tl_user_id, tl_baid)]
```

How many broker account - broker account dyads are there? How many user-user?

```{r}
ba.dyads <- fpt.follower[, list(N=.N), by=list(brokerAccount_id, tl_baid)]
user.dyads <- fpt.follower[, list(N=.N), by=list(user_id, tl_user_id)]

ptm <- proc.time()
tl_baids <- ba.dyads[, unique(tl_baid)]
resdts <- mclapply(tl_baids, mc.cores=20,
    mc.preschedule=FALSE,
    FUN=function(tl.baid) {
#     print(which(tl_baids==tl.baid))

#     user.fpt <- fpt.follower[tl_baid==tl.baid,
#                              !c('version','correlationId',
#                                 'openPrice','openTime','closePrice','closeTime',
#                                 'original_id','residual_id','volume',
#                                 'currency1','currency2','direction'
#                                 'takeProfit','stopLoss','openBalance',
#                                 'tradePnl','commission','baseCurrency'),
#                              with=FALSE]
    user.fpt <- fpt.follower[tl_baid==tl.baid,
                             list(brokerAccount_id, openCause_id,
                                  id, openTime, closeTime,
                                  status, closureReason,
                                  user_id
                                  )]
    user.fpt[, `:=`(N=.N,
                    Nreason=length(unique(closureReason)),
                    NA.C=any(closureReason==''),
                    SF.C=any(closureReason=='STANDARD_FOLLOW'),
                    ER.C=any(closureReason=='ENDED_RELATIONSHIP'),
                    DD.C=any(closureReason=='VMC_DRAWDOWN'),
                    OD.C=any(closureReason=='VMC_OPEN_DRAWDOWN'),
                    EC.C=any(closureReason=='EXTERNAL_CLOSE'),
                    UI.C=any(closureReason=='USER_INITIATED')
                    ), 
                   by=list(brokerAccount_id, openCause_id)]
#     bads <- user.fpt[N > 1 & Nreason > 1]
    setkey(user.fpt,brokerAccount_id,openCause_id)
    user.fpt <- unique(user.fpt)
#     user.fpt[, `:=`( NA.C=closureReason=='',
#                     SF.C=closureReason=='STANDARD_FOLLOW',
#                     ER.C=closureReason=='ENDED_RELATIONSHIP',
#                     DD.C=closureReason=='VMC_DRAWDOWN',
#                     OD.C=closureReason=='VMC_OPEN_DRAWDOWN',
#                     EC.C=closureReason=='EXTERNAL_CLOSE',
#                     UI.C=closureReason=='USER_INITIATED')]
    # apparently we have to check for duplicates in the user fpt field
    # i.e. some users have multiple records corresponding to a single
    # open trade leader order
    # hopefully this is just some company debugging shit
    # nope: looks like the company regularly splits follower orders into multiple batches
    # no clue why... nothing in ToS
#     bads <- NULL
#     if(any(duplicated(user.fpt))) {
# #         cat('\n\nduplicated entries, distinct closure\n')
#         user.fpt.dups <- user.fpt
#         user.fpt.dups[, `:=`(N=.N,
#                              Nreason=length(unique(closureReason))),
#                       by=list(brokerAccount_id, openCause_id)]
# #         print(user.fpt.dups[ N > 1 & Nreason > 1])
#         bads <- user.fpt.dups[N > 1 & Nreason > 1]
#         user.fpt[, `:=`(NA.C=any(closureReason==''),
#                         SF.C=any(closureReason=='STANDARD_FOLLOW'),
#                         ER.C=any(closureReason=='ENDED_RELATIONSHIP'),
#                         DD.C=any(closureReason=='VMC_DRAWDOWN'),
#                         OD.C=any(closureReason=='VMC_OPEN_DRAWDOWN'),
#                         EC.C=any(closureReason=='EXTERNAL_CLOSE'),
#                         UI.C=any(closureReason=='USER_INITIATED')
#                         ), 
#                  by=list(brokerAccount_id, openCause_id)]
#         user.fpt <- unique(user.fpt)
#     } else {
#         user.fpt[, `:=`(N=1,Nreason=1)]
#     }

    tl.fpt <- fpt[brokerAccount_id == tl.baid,
                  list(openCause_id=id,
                       tl_baid=brokerAccount_id,
                       tl_user_id=user_id,
#                        currency1, currency2, direction,
                       tl_status=status)]
    setkey(tl.fpt,openCause_id)

    tl.ids <- tl.fpt[, unique(openCause_id)]
    user.baids <- fpt.follower[tl_baid == tl.baid, unique(brokerAccount_id)]
    
    tl.grid <- CJ(openCause_id=tl.ids, brokerAccount_id=user.baids)
    setkey(tl.grid,brokerAccount_id,openCause_id)
    tl.grid <- merge(tl.grid,tl.fpt,all.x=TRUE)
    setkey(tl.grid,brokerAccount_id,openCause_id)
    tl.grid <- merge(tl.grid,user.fpt,all.x=TRUE)

    cat(which(tl_baids==tl.baid), '::', object.size(tl.grid) / (2^20), 'Mb\n')

#     list(tl.grid, bads)
    tl.grid
})
print(proc.time() - ptm)

system.time(all.grids <- rbindlist(resdts))
setkey(all.grids, tl_baid, brokerAccount_id)

# all.grids <- lapply(resdts, function(dt.list) dt.list[[1]])
# all.bads <- lapply(resdts, function(dt.list) dt.list[[2]])

#temporary fixer upper:
# all.grids <- lapply(all.grids, function(x) {
#     if(!('N' %in% names(x))) {
#         x[, `:=`(N=1,Nreason=1)]
#     }
#     x
# })

# system.time(all.bads <- rbindlist(all.bads))
# system.time(all.bads <- Reduce(rbind,all.bads))
# this shit has a bug, using do.call rbind instead
# which also has a bug, what the ever-loving fuck
# let's try reduce???
# "length 1364523120 is too large for hashing"
# all.grids <- rbindlist(all.grids)
# all.grids <- do.call(rbind,all.grids)
# system.time(all.grids <- Reduce(rbind,all.grids))

# tabulate quit reasons
closure.reasons <- all.grids[, list(N=.N,Nreason=min(Nreason)),
                             by=list(NA.C,SF.C,ER.C,DD.C,OD.C,EC.C,UI.C)]
closure.reasons <- closure.reasons[order(closure.reasons$Nreason, -closure.reasons$N)]
closure.reasons[, reasons := paste0(c('','.')[NA.C + 1],
                                    c('','-')[SF.C + 1],
                                    c('','R')[ER.C + 1],
                                    c('','D')[DD.C + 1],
                                    c('','O')[OD.C + 1],
                                    c('','X')[EC.C + 1],
                                    c('','U')[UI.C + 1])]
closure.reasons[is.na(NA.C), reasons := '']

all.grids[Nreason > 0, reasons := paste0(c('','.')[NA.C + 1],
                                         c('','-')[SF.C + 1],
                                         c('','R')[ER.C + 1],
                                         c('','D')[DD.C + 1],
                                         c('','O')[OD.C + 1],
                                         c('','X')[EC.C + 1],
                                         c('','U')[UI.C + 1])]
# all.grids[, reasons := paste0(ifelse(NA.C,'.',''),
#                               ifelse(SF.C,'-',''),
#                               ifelse(ER.C,'R',''),
#                               ifelse(DD.C,'D',''),
#                               ifelse(OD.C,'O',''),
#                               ifelse(EC.C,'X',''),
#                               ifelse(UI.C,'U','')
#                               )]
all.grids[is.na(NA.C), reasons := '']
all.grids[, reasons := as.factor(reasons)]

# merge in trade leader open time
tl.open.times <- fpt[, list(openCause_id=id, tl_openTime = openTime)]
setkey(tl.open.times)
setkey(all.grids,openCause_id)
all.grids <- merge(all.grids,tl.open.times, all.x=TRUE)
setkey(all.grids, tl_baid, brokerAccount_id)

# split to single stream
all.tl.opens <- all.grids[, list(brokerAccount_id, tl_baid, etime=tl_openTime,
                                 type='BO',
                                 openCause_id, id=openCause_id,
                                 user_id, tl_user_id,
                                 reasons)]
all.user.opens <- all.grids[!is.na(openTime), list(brokerAccount_id, tl_baid, etime=openTime,
                                                   type='UO',
                                                   openCause_id, id,
                                                   user_id, tl_user_id,
                                                   reasons)]
all.user.closes <- all.grids[!is.na(closeTime), list(brokerAccount_id, tl_baid, etime=closeTime,
                                                     type='UC',
                                                     openCause_id, id,
                                                     user_id, tl_user_id,
                                                     reasons)]
tl.events <- rbind(all.tl.opens, all.user.opens, all.user.closes)
tl.events[, type := as.factor(type)]
setkey(tl.events, brokerAccount_id, tl_baid, etime)

rm(all.tl.opens, all.user.opens, all.user.closes)
# rm(resdts, all.grids)

# drop initial part of stream
# i.e. all broker events before the user's first action
tl.events[, nuserevents := cumsum(type != 'BO'), by=list(brokerAccount_id, tl_baid)]
tl.events <- tl.events[nuserevents > 0, !'nuserevents', with=FALSE]

# gotta figure out if certain broker trades are just never followed by anybody
tl.follows <- tl.events[type != 'BO', list(nfollows = .N), by=openCause_id]
setkey(tl.events, openCause_id)
setkey(tl.follows, openCause_id)
tl.events <- merge(tl.events, tl.follows, all.x=TRUE)
tl.events[is.na(nfollows), nfollows := 0]

# drop broker opens with no follows?
tl.events <- tl.events[nfollows > 0]

# get runs of blanks (calling it a segment)
# ensure sorting by time first
tl.events[, newsegment := xor(is.na(user_id),
                              is.na(c(NA,head(user_id,-1)))),
          by=list(brokerAccount_id, tl_baid)]
tl.events[, segmentid := cumsum(newsegment),
          by=list(brokerAccount_id, tl_baid)]
tl.events[, `:=`(segment.nofollow = is.na(user_id[1]),
                 segment.length = .N),
          by=list(brokerAccount_id, tl_baid, segmentid)]
segment.stats <- tl.events[, list(segment.nofollow=segment.nofollow[1],
                                  segment.length=segment.length[1],
                                  seg.tdiff=(etime[.N]-etime[1])/86400000),
                           by=list(brokerAccount_id, tl_baid, segmentid)]
segment.stats[, followsleft := Reduce('+',
                                      as.numeric(!segment.nofollow),
                                      accumulate=TRUE,right=TRUE),
              by=list(brokerAccount_id, tl_baid)]

table(segment.stats[(segment.nofollow), followsleft>0])
txtdensity(segment.stats[segment.nofollow & followsleft > 0, seg.tdiff])
txtdensity(segment.stats[segment.nofollow & followsleft == 0, seg.tdiff])
quantile(segment.stats[segment.nofollow & followsleft > 0, seg.tdiff],
         seq(0,1,0.01))
quantile(segment.stats[segment.nofollow & followsleft == 0, seg.tdiff],
         seq(0,1,0.01))

# classify segments
segment.stats[, relation.break := ]



# setkey(tl.events, id)
# addend.data <- fpt[, list(id, version, cp=paste0(currency1,currency2))]
# setkey(addend.data, id)
# tl.events <- merge(tl.events, addend.data, all.x=TRUE) 


setkey(tl.events, brokerAccount_id, tl_baid, etime)

```



```{r, eval=FALSE}
ba.reasons <- fpt.follower[, list(N=.N,
                                  minotime=min(openTime, na.rm=TRUE),
                                  minctime=min(closeTime, na.rm=TRUE),
                                  maxotime=max(openTime, na.rm=TRUE),
                                  maxctime=max(closeTime, na.rm=TRUE)
                                  ), by=list(brokerAccount_id, tl_baid, closureReason)]
user.reasons <- fpt.follower[, list(N=.N,
                                    minotime=min(openTime, na.rm=TRUE),
                                    minctime=min(closeTime, na.rm=TRUE),
                                    maxotime=max(openTime, na.rm=TRUE),
                                    maxctime=max(closeTime, na.rm=TRUE)
                                    ), by=list(user_id, tl_user_id, closureReason)]

summary(ba.reasons)
summary(user.reasons)

setkey(ba.reasons, brokerAccount_id, tl_baid)
setkey(user.reasons, user_id, tl_user_id)

summary(fpt.follower[closureReason=='', openTime])
summary(fpt.follower[closureReason!='', openTime])

muser.reasons <- melt(user.reasons, id.vars=c('user_id','tl_user_id','closureReason'))
muser.reasons[closureReason == '', closureReason := 'NA']
wuser.reasons <- dcast.data.table(muser.reasons, user_id + tl_user_id ~ closureReason + ...) 

# must append user's own last time of use
user.max.times <- fpt[, list(maxotime=max(openTime, na.rm=TRUE),
                             maxctime=max(closeTime, na.rm=TRUE)),
                      by=user_id]
setkey(user.max.times, user_id)
setkey(wuser.reasons, user_id)
wuser.reasons <- merge(wuser.reasons, user.max.times, all.x=TRUE)

wuser.reasons[ENDED_RELATIONSHIP_maxctime < STANDARD_FOLLOW_maxotime]
```



```{r, eval=FALSE}
# setnames(fpt, c('openPrice','openTime','closePrice','closeTime',
#            'dollarPnl','tradePnl','openBalance'),
#          c('openprice','opendate','closeprice','closedate',
#            'dollarpnl','tradepnl','openbalance'))
# fpt[,longtr := 2 * as.numeric(direction=='LONG') - 1]
# fpt[,clopdiff := closeprice - openprice]
# fpt[,pctreturn := (clopdiff / openprice) * longtr]
# fpt <- fpt[!is.na(pctreturn)]

# split out follower trades
fpt.f <- fpt[!is.na(openCause_id) | !is.na(closeCause_id)]
fpt <- fpt[is.na(openCause_id) & is.na(closeCause_id)]
fpt <- fpt[closureReason == '']
fpt.f[is.na(openCause_id), openCause_id := closeCause_id]
setkey(fpt,id)

fpt.f2 <- fpt.f[,list(followers = .N), by=list(id=openCause_id)]
setkey(fpt.f2,id)

fpt <- merge(fpt,fpt.f2,all.x=TRUE)
fpt[,indeptrade := as.numeric(is.na(followers))]

# merge in user ids
setkey(fpt,brokerAccount_id)
fpt <- merge(fpt,ba,all.x=TRUE)

# save and clean
saveRDS(fpt,'../../forexposition.Rds')
rm(fpt, fpt.f, fpt.f2); gc()



# make dbap
dbap <- readRDS('DailyBrokerAccountPerformance.Rds')
dbap[,c('version','intraDayHigh','intraDayLow','maxDD','peakHigh','peakLow',
        'todateClosedRoi','todateNetRoi') := NULL]

# merge in user ids
setkey(dbap,brokerAccount_id)
dbap <- merge(dbap,ba,all.x=TRUE)

# save and clean
saveRDS(dbap,'../../dailybrokeraccount.Rds')
rm(dbap); gc()





# make ld
fl <- readRDS('FriendLink.Rds')
um <- readRDS('UserMessage.Rds')

fl[,c('id','version') := NULL]
um <- um[type=='FRIEND_LINK_REQUEST',list(sender_id, recipient_id, senddate=sendDate)]
setnames(fl,c('friend1_id','friend2_id'),
         c('user_id','alter_id'))
setnames(um,c('sender_id','recipient_id'),
         c('user_id','alter_id'))

# symmetrize
fl <- rbind(fl,fl[,list(user_id=alter_id, alter_id=user_id)], use.names=TRUE)
um <- rbind(um,um[,list(user_id=alter_id, alter_id=user_id, senddate)], use.names=TRUE)

# take last date by friendship
um <- um[,list(senddate=max(senddate)), by=list(user_id,alter_id)]

# merge in dates...
setkey(fl,user_id,alter_id)
setkey(um,user_id,alter_id)
ld <- merge(fl,um,all.x=TRUE)

ld <- ld[!is.na(senddate)]

# save and clean
saveRDS(ld,'../../linkdata.Rds')
rm(fl, um, ld); gc()
```
